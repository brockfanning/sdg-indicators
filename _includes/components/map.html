{% assign id = page.indicator | slugify %}
<svg height="600" width="960" id="map-{{ id }}"></div>

<style>
/*
.counties {
  fill: none;
}

.states {
  fill: none;
  stroke: #fff;
  stroke-linejoin: round;
}
*/
</style>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/topojson.v2.min.js"></script>
<script>
var container = '#map-{{ id }}';
var svg = d3.select(container);
var width = +svg.attr('width');
var height = +svg.attr('height');
var path = d3.geoPath();

// This hardcoded list adapted from: https://gist.github.com/mbostock/4090846#file-us-state-names-tsv
// The idea is that the strings below are what would be used in a subfolder
// approach to disaggregation. Ie, the New York data would be in a subfolder
// called 'new-york'.
var state_ids = {
  'alabama': '01',
  'alaska': '02',
  'arizona': '04',
  'arkansas': '05',
  'california': '06',
  'colorado': '08',
  'connecticut': '09',
  'delaware': '10',
  'district-of-columbia': '11',
  'florida': '12',
  'georgia': '13',
  'hawaii': '15',
  'idaho': '16',
  'illinois': '17',
  'indiana': '18',
  'iowa': '19',
  'kansas': '20',
  'kentucky': '21',
  'louisiana': '22',
  'maine': '23',
  'maryland': '24',
  'massachusetts': '25',
  'michigan': '26',
  'minnesota': '27',
  'mississippi': '28',
  'missouri': '29',
  'montana': '30',
  'nebraska': '31',
  'nevada': '32',
  'new-hampshire': '33',
  'new-jersey': '34',
  'new-mexico': '35',
  'new-york': '36',
  'north-carolina': '37',
  'north-dakota': '38',
  'ohio': '39',
  'oklahoma': '40',
  'oregon': '41',
  'pennsylvania': '42',
  'rhode-island': '44',
  'south-carolina': '45',
  'south-dakota': '46',
  'tennessee': '47',
  'texas': '48',
  'utah': '49',
  'vermont': '50',
  'virginia': '51',
  'washington': '53',
  'west-virginia': '54',
  'wisconsin': '55',
  'wyoming': '56',
  'america-samoa': '60',
  'federated-states-of-micronesia': '64',
  'guam': '66',
  'marshall-islands': '68',
  'northern-mariana-islands': '69',
  'palau': '70',
  'puerto-rico': '72',
  'us-minor-outlying-islands': '74',
  'us-virgin-islands': '78'
};

d3.queue()
  .defer(d3.csv, '{{ site.baseurl }}/data/indicator_{{ id }}.csv')
  .defer(d3.json, 'https://d3js.org/us-10m.v1.json')
  .await(ready);

function ready(error, data, us) {
  if (error) throw error;

  // A future improvement would be to implement disaggregation filtering
  // on these maps, but for now, we are just doing a hardcoded visualization
  // of the aggregated data for the most recent year, 2016. A necessary
  // improvement would be some sort of slider widget for changing the year.
  var year = '2016';

  // To get the aggregated data, we need the rows that have the correct year,
  // a value, but no other columns filled out. So first get the other columns.
  var otherColumns = [];
  var hasYear = false;
  var hasValue = false;
  var hasState = false;
  for (var column in data[0]) {
    if ('year' == column) {
      hasYear = true;
    }
    else if ('value' == column) {
      hasValue = true;
    }
    else if ('state' == column) {
      hasState = true;
    }
    else {
      otherColumns.push(column);
    }
  }

  // We can't continue without certain minimum columns.
  if (!hasYear || !hasValue || !hasState) {
    return;
  }

  // Filter down the data.
  data = data.filter(function(row) {
    // Also ensure the correct year.
    if (row.year != year) {
      return false;
    }
    // We only care about rows with state.
    if (row.state == '') {
      return false;
    }
    // We only want aggregates, so there should be no other columns present.
    for (var i in otherColumns) {
      if (row[otherColumns[i]] != '') {
        return false;
      }
    }
    return true;
  });

  // Map the data according to the state's id code.
  data_by_id = {};
  for (var row in data) {
    data_by_id[state_ids[data[row].state]] = data[row].value;
  }

  var x = d3.scaleLinear()
    .domain([1, 10])
    .rangeRound([600, 860]);

  var color = d3.scaleThreshold()
    .domain(d3.range(2, 10))
    .range(d3.schemeBlues[9]);

  var g = svg.append('g')
    .attr('class', 'key')
    .attr('transform', 'translate(0,40)');

  g.selectAll('rect')
    .data(color.range().map(function(d) {
      d = color.invertExtent(d);
      if (d[0] == null) d[0] = x.domain()[0];
      if (d[1] == null) d[1] = x.domain()[1];
      return d;
    }))
    .enter().append('rect')
      .attr('height', 8)
      .attr('x', function(d) { return x(d[0]); })
      .attr('width', function(d) { return x(d[1]) - x(d[0]); })
      .attr('fill', function(d) { return color(d[0]); });

  g.append('text')
    .attr('class', 'caption')
    .attr('x', x.range()[0])
    .attr('y', -6)
    .attr('fill', '#000')
    .attr('text-anchor', 'start')
    .attr('font-weight', 'bold')
    .text('{{ page.title }}');

  g.call(d3.axisBottom(x)
      .tickSize(13)
      .tickFormat(function(x, i) { return i ? x : x + '%'; })
      .tickValues(color.domain()))
    .select('.domain')
      .remove();

  svg.append('g')
      .attr('class', 'states')
    .selectAll('path')
    .data(topojson.feature(us, us.objects.states).features)
    .enter().append('path')
      .attr('fill', function(d) { return color(d.rate = data_by_id[d.id]); })
      .attr('d', path)
    .append('title')
      .text(function(d) { return d.rate; });
}
</script>